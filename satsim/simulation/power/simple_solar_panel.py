__all__ = ['SimpleSolarPanel']
import torch

from satsim.architecture import Module, VoidStateDict, constants
from satsim.utils import to_rotation_matrix

from ..base import PowerNodeMixin, BatteryStateDict


class SimpleSolarPanel(Module[VoidStateDict], PowerNodeMixin):

    def __init__(
        self,
        *args,
        panel_direction_in_body: torch.Tensor,
        panel_area: torch.Tensor,
        panel_efficiency: torch.Tensor,
        **kwargs,
    ) -> None:
        """
        Initializes the SimpleSolarPanel object with the given parameters.
        Args:
            panel_normal_in_body_frame (torch.Tensor): A tensor representing the normal vector 
                of the solar panel in the body frame. Must be a non-zero vector.
            panel_area (torch.Tensor): A tensor representing the area of the solar panel. 
                Must be a positive value, in m^2.
            panel_efficiency (torch.Tensor): A tensor representing the efficiency of the 
                solar panel. Must be within the range (0, 1].
        Raises:
            ValueError: If `panel_area` is not a positive value.
            ValueError: If `panel_efficiency` is not within the range (0, 1].
            ValueError: If `panel_normal_in_body_frame` is a zero vector.
        Notes:
            The `panel_normal_in_body_frame` is normalized during initialization.
        """
        super().__init__(*args, **kwargs)

        if panel_area <= 0:
            raise ValueError("panel_area must be positive")
        if not (0 < panel_efficiency <= 1):
            raise ValueError("panel_efficiency must be in (0,1]")
        if torch.norm(panel_direction_in_body) < 1e-5:
            raise ValueError(
                "panel_direction_in_body_frame must be normalized")

        panel_direction_in_body = (panel_direction_in_body /
                                   torch.norm(panel_direction_in_body))

        self.register_buffer(
            '_panel_direction_in_body',
            panel_direction_in_body,
            persistent=False,
        )
        self.register_buffer(
            '_panel_area',
            panel_area,
            persistent=False,
        )
        self.register_buffer(
            '_panel_efficiency',
            panel_efficiency,
            persistent=False,
        )

    @property
    def panel_direction_in_body(self) -> torch.Tensor:
        return self.get_buffer('_panel_direction_in_body')

    @property
    def panel_area(self) -> torch.Tensor:
        return self.get_buffer('_panel_area')

    @property
    def panel_efficiency(self) -> torch.Tensor:
        return self.get_buffer('_panel_efficiency')

    def forward(
        self,
        state_dict: VoidStateDict,
        *args,
        spacecraft_position_inertial: torch.Tensor,
        sun_position_inertial: torch.Tensor,
        spacecraft_attitude_mrp: torch.Tensor,
        shadow_factor: torch.Tensor | None = None,
        battery_state_dict: BatteryStateDict,
        **kwargs,
    ) -> tuple[VoidStateDict, tuple[torch.Tensor, BatteryStateDict]]:
        """
        Computes the net power generated by the solar panel given the spacecraft and sun positions, attitude, and optional shadow factor.
        Args:
            state_dict (SolarPanelStateDict): Dictionary containing the current state of the solar panel.
            spacecraft_position_inertial (torch.Tensor): Tensor of shape (batch_size, 3) representing the spacecraft position in the inertial frame.
            sun_position_inertial (torch.Tensor): Tensor of shape (batch_size, 3) representing the sun position in the inertial frame.
            spacecraft_attitude_mrp (torch.Tensor): Tensor of shape (batch_size, 3) representing the spacecraft attitude in Modified Rodrigues Parameters (MRP).
            shadow_factor (torch.Tensor | None, optional): Tensor of shape (batch_size,) representing the shadowing factor for each sample. If None, assumes full sunlight (no shadow).
        Returns:
            tuple:
                - state_dict (SolarPanelStateDict): Updated state dictionary with computed projected area and sun distance factor.
                - tuple[torch.Tensor]: Tuple containing the net power tensor of shape (batch_size,).
        """

        if shadow_factor is None:
            shadow_factor = 1.

        sun_position_wrt_spacecraft_in_inertial = sun_position_inertial - spacecraft_position_inertial
        sun_distance = torch.norm(
            sun_position_wrt_spacecraft_in_inertial,
            dim=-1,
            keepdim=True,
        )

        sun_direction_inertial = sun_position_wrt_spacecraft_in_inertial / (
            sun_distance + 1e-10)

        dcm_body_wrt_inertial = to_rotation_matrix(spacecraft_attitude_mrp)

        sun_direction_in_body = torch.matmul(
            dcm_body_wrt_inertial,
            sun_direction_inertial.unsqueeze(-1)).squeeze(-1)

        cos_theta = torch.sum(sun_direction_in_body *
                              self.panel_direction_in_body,
                              dim=-1)
        projected_area = self.panel_area * torch.clamp(cos_theta, min=0.0)

        sun_distance_factor = (constants.ASTRONOMICAL_UNIT**
                               2) / (sun_distance.squeeze(-1)**2 + 1e-10)

        sun_power_factor = (constants.SOLAR_FLUX_AT_EARTH *
                            sun_distance_factor * shadow_factor)
        net_power = sun_power_factor * projected_area * self.panel_efficiency

        _, battery_state_dict = self.update_power_status(
            net_power, battery_state_dict)

        return state_dict, (net_power, battery_state_dict)
